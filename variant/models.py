from collections import defaultdict
from typing import List, Union, Optional

from django.contrib.postgres.fields import JSONField
from django.db import models, transaction

from dataset import constants as constants
from urn.models import UrnModel
from dataset.models import ScoreSet
from urn.validators import validate_mavedb_urn_variant
from variant.validators import (
    validate_nt_variant,
    validate_pro_variant,
    validate_splice_variant,
    validate_variant_json,
    validate_columns_match,
)

# 'score' should be the first column in a score dataset
column_order = defaultdict(lambda: 1)
column_order[constants.required_score_column] = 0


def default_data_dict():
    return dict(
        {constants.variant_score_data: {}, constants.variant_count_data: {}}
    )


@transaction.atomic
def assign_public_urn(variant):
    """
    Assigns a public urn of the form <parent_urn>-#[0-9]+ Blocks until it can
    place of lock the passed `variant's` and `scoreset` parent. Assumes that
    the parent is already public with a public urn.

    Does nothing if passed model is already public.

    Parameters
    ----------
    variant : `Variant`
        The variant instance to assign a public urn to.

    Raises
    ------
    `AttributeError` : Parent does not have a public urn.

    Returns
    -------
    `Variant`
        variant with new urn or same urn if already public.
    """
    from dataset.models.scoreset import ScoreSet

    if not variant.has_public_urn:
        parent = (
            ScoreSet.objects.filter(id=variant.scoreset.id)
            .select_for_update(nowait=False)
            .first()
        )

        if not parent.has_public_urn:
            raise AttributeError(
                "Cannot assign a public urn when parent has a temporary urn."
            )

        child_value = parent.last_child_value + 1
        variant.urn = "{}#{}".format(parent.urn, child_value)
        parent.last_child_value = child_value
        parent.save()
        variant.save()

        # Refresh the variant and nested parents
        variant = (
            Variant.objects.filter(id=variant.id)
            .select_for_update(nowait=False)
            .first()
        )

    return variant


class Variant(UrnModel):
    """
    This is the class representing an individual variant belonging to one
    and only one ScoreSet instance. The numerical parameters of a variant
    are held in a JSONField, which can be easily queried and extended as
    needed.

    Attributes
    ----------
    urn : `str`, optional.
        URN identifier. Autogenerated.

    hgvs_nt : `str`, required.
        The nucleotide HGVS string belonging to the variant. Should be
        'g' if hgvs_splice is also present.

    hgvs_splice : `str`, required.
        The transcript HGVS string belonging to the variant. Should use the
        'c/n' prefix.

    hgvs_pro : `str`, required.
        The protein HGVS string belonging to the variant. Should use the 'p'
        prefix

    scoreset : `ScoreSet`, required.
        The associated scoreset of the instance.

    data : `JSONField`
        The variant's numerical data.

    """

    # ---------------------------------------------------------------------- #
    #                       Class members/functions
    # ---------------------------------------------------------------------- #
    class Meta:
        verbose_name = "Variant"
        verbose_name_plural = "Variants"

    # ---------------------------------------------------------------------- #
    #                       Required Model fields
    # ---------------------------------------------------------------------- #
    urn = models.CharField(
        validators=[validate_mavedb_urn_variant], **UrnModel.default_urn_kwargs
    )

    hgvs_nt = models.TextField(
        null=True, default=None, validators=[validate_nt_variant]
    )

    hgvs_splice = models.TextField(
        null=True, default=None, validators=[validate_splice_variant]
    )

    hgvs_pro = models.TextField(
        null=True, default=None, validators=[validate_pro_variant]
    )

    scoreset = models.ForeignKey(
        to="dataset.ScoreSet",
        on_delete=models.PROTECT,
        related_name="variants",
        null=False,
        default=None,
    )

    # ---------------------------------------------------------------------- #
    #                      Optional Model fields
    # ---------------------------------------------------------------------- #
    data = JSONField(
        verbose_name="Data columns",
        default=default_data_dict,
        validators=[validate_variant_json],
    )

    # ---------------------------------------------------------------------- #
    #                       Methods
    # ---------------------------------------------------------------------- #
    @transaction.atomic
    def save(self, *args, **kwargs):
        if self.parent:
            validate_columns_match(self, self.parent)
        return super().save(*args, **kwargs)

    @property
    def parent(self) -> Optional[ScoreSet]:
        if not hasattr(self, "scoreset"):
            return None
        return self.scoreset

    @property
    def hgvs(self) -> Optional[str]:
        return self.hgvs_nt or self.hgvs_pro

    @classmethod
    @transaction.atomic
    def bulk_create(cls, parent, variant_kwargs_list, batch_size=None) -> int:
        num_variants = len(list(variant_kwargs_list))
        variant_urns = Variant.bulk_create_urns(num_variants, parent)
        variants = (
            Variant(urn=urn, scoreset=parent, **kwargs)
            for urn, kwargs in zip(variant_urns, variant_kwargs_list)
        )
        cls.objects.bulk_create(variants, batch_size=batch_size)
        parent.save()
        return parent.variants.count()

    @staticmethod
    def bulk_create_urns(n, parent, reset_counter=False) -> List[str]:
        start_value = 0 if reset_counter else parent.last_child_value
        parent_urn = parent.urn
        child_urns = [
            "{}#{}".format(parent_urn, start_value + (i + 1)) for i in range(n)
        ]
        current_value = start_value + n
        parent.last_child_value = current_value
        return child_urns

    @property
    def score_columns(self) -> List[str]:
        return self.__columns(dt="scores")

    @property
    def score_data(self) -> List[Optional[Union[str, int]]]:
        return self.__data_as_list(dt="scores")

    @property
    def count_columns(self) -> List[str]:
        return self.__columns(dt="counts")

    @property
    def count_data(self) -> List[Optional[Union[str, int]]]:
        return self.__data_as_list(dt="counts")

    # ---------------------- Private --------------------------------------- #
    def __columns(self, dt="scores") -> List[str]:
        if dt == "scores":
            data_key = constants.variant_score_data
        elif dt == "counts":
            data_key = constants.variant_count_data
        else:
            raise ValueError(
                f"'{dt}' is an unknown data type. "
                f"Use either 'scores' or 'counts'"
            )

        return [
            constants.hgvs_nt_column,
            constants.hgvs_splice_column,
            constants.hgvs_pro_column,
        ] + list(
            sorted(
                self.data[data_key].keys(),
                key=lambda x: column_order[x],
            )
        )

    def __data_as_list(self, dt="scores") -> List[Optional[Union[str, int]]]:
        if dt == "scores":
            columns = self.score_columns
            data_key = constants.variant_score_data
        elif dt == "counts":
            columns = self.count_columns
            data_key = constants.variant_count_data
        else:
            raise ValueError(
                f"'{dt}' is an unknown data type. "
                f"Use either 'scores' or 'counts'"
            )

        result = []
        for column in columns:
            if column == constants.hgvs_nt_column:
                result.append(self.hgvs_nt)
            elif column == constants.hgvs_splice_column:
                result.append(self.hgvs_splice)
            elif column == constants.hgvs_pro_column:
                result.append(self.hgvs_pro)
            else:
                result.append(self.data[data_key][column])

        return result
